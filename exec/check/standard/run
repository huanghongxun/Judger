#!/bin/bash
#
# 评测提交的脚本
#
# 用法：$0 <datadir> <timelimit> <chrootdir> <workdir> <run-uuid> <run> <compare>
#
# <datadir>      包含数据文件的文件夹的绝对路径
# <timelimit>    运行时间限制，格式为 %d:%d，如 1:3 表示测试点时间限制
#                为 1s，如果运行时间超过 3s 则结束程序
# <chrootdir>    子环境
# <workdir>      程序的工作文件夹，为了保证安全，请务必将运行路径设置
#                为空文件夹，特别是保证不可以包含标准输出文件
# <run-uuid>     运行的 uuid，用于索引运行文件夹位置
# <run>          运行程序的脚本的文件夹
# <compare>      比较程序/脚本文件夹的文件夹
#
# 必须包含的环境变量：
#   RUNGUARD        runguard 的路径
#   RUNUSER         选手程序运行的账户
#   RUNGROUP        选手程序运行的账户组
#   SCRIPTMEMLIMIT  比较脚本运行内存限制
#   SCRIPTTIMELIMIT 比较脚本执行时间
#   SCRIPTFILELIMIT 比较脚本输出限制
#
# 可选环境变量
#   MEMLIMIT     运行内存限制，单位为 KB
#   PROCLIMIT    进程数限制
#   FILELIMIT    文件写入限制，单位为 KB
#
# 默认的比较脚本都可以放在配置服务中

set -e
trap 'cleanup ; error' EXIT

cleanup ()
{
    # 删除创建过的文件

    if [ -s runguard.err ]; then
        echo "************* runguard error *************" >> system.out
        cat runguard.err >> system.out
    fi
}

cleanexit ()
{
    set +e
    trap - EXIT

    cleanup

    exit $1
}

# 导入 runcheck 函数
. "$JUDGE_UTILS/utils.sh"
. "$JUDGE_UTILS/logging.sh"
. "$JUDGE_UTILS/chroot_setup.sh"

CPUSET=""
CPUSET_OPT=""
OPTINT=1
while getopts "n:" opt; do
    case $opt in
        n)
            OPTSET="$OPTARG"
            ;;
        :)
            >&2 echo "Option -$OPTARG requires an argument."
            ;;
    esac
done

shift $((OPTIND-1))
[ "$1" == "--" ] && shift

if [ -n "$CPUSET" ]; then
    CPUSET_OPT="-P $CPUSET"
fi

MEMLIMIT_OPT=""
if [ -n "$MEMLIMIT" ]; then
    MEMLIMIT_OPT="--memory-limit $MEMLIMIT"
fi

FILELIMIT_OPT=""
if [ -n "$FILELIMIT" ]; then
    FILELIMIT_OPT="--file-limit $FILELIMIT --stream-size $FILELIMIT"
fi

PROCLIMIT_OPT=""
if [ -n "$PROCLIMIT" ]; then
    PROCLIMIT_OPT="--nproc $PROCLIMIT"
fi

LOGFILE="$LOGDIR/judge.$(hostname | cut -d . -f 1).log"
LOGLEVEL=$LOG_DEBUG
PROGNAME="$(basename "$0")"

if [ "$DEBUG" ]; then
    export VERBOSE=$LOG_DEBUG
else
    export VERBOSE=$LOG_ERR
fi

GAINROOT="sudo -n"
PROGRAM="compile/run"

[ $# -ge 4 ] || error "not enough arguments"

DATADIR="$1"; shift
TIMELIMIT="$1"; shift
CHROOTDIR="$1"; shift
WORKDIR="$1"; shift
RUN_UUID="$1"; shift
RUN_SCRIPT="$1"
COMPARE_SCRIPT="$2"
COMPARE_ARGS="$3"

TESTIN="$DATADIR/input"
TESTOUT="$DATADIR/output"

[ -d "$TESTIN" ] || error "input data does not exist: $TESTIN"
[ -d "$TESTOUT" ] || error "output data does not exist: $TESTOUT"
if [ ! -d "$WORKDIR" ] || [ ! -w "$WORKDIR" ] || [ ! -x "$WORKDIR" ]; then
    error "Working directory does not exist: $WORKDIR"
fi

[ -x "$WORKDIR/$PROGRAM" ] || error "Program does not exist"
[ -d "$COMPARE_SCRIPT" ] || error "Compare script does not exist"
[ -d "$RUN_SCRIPT" ] || error "Run script does not exist"
[ -x "$RUNGUARD" ] || error "runguard does not exist"

chmod a+x "$WORKDIR"

# 检查运行脚本

RUNDIR="$WORKDIR/run-$RUN_UUID"
mkdir -m 0777 -p "$RUNDIR"

chmod -R +x "$RUN_SCRIPT/run"
chmod -R +x "$COMPARE_SCRIPT/run"

cd "$RUNDIR"

touch judge.out
touch program.out program.err
touch program.meta runguard.err
touch compare.meta compare.err

mkdir -m 0777 -p "$RUNDIR/run" # 运行的临时文件都在这里
mkdir -m 0777 -p "$RUNDIR/feedback"
mkdir -m 0777 -p "$RUNDIR/work"
mkdir -m 0777 -p "$RUNDIR/work/judge"
mkdir -m 0777 -p "$RUNDIR/work/judge_utils"
mkdir -m 0777 -p "$RUNDIR/work/compare"
mkdir -m 0777 -p "$RUNDIR/work/run"
mkdir -m 0777 -p "$RUNDIR/work/feedback"
mkdir -m 0777 -p "$RUNDIR/merged"
# 将测试数据文件夹（内含输入数据，且其中 testdata.in 为标准输入数据文件名），编译好的程序，运行文件夹通过 overlayfs 绑定
$GAINROOT mount -t aufs none -odirs="$RUNDIR/work"=rw:"$CHROOTDIR"=ro "$RUNDIR/merged"
$GAINROOT mount -t aufs none -odirs="$RUNDIR/run"=rw:"$WORKDIR/compile"=ro:"$TESTIN"=ro "$RUNDIR/merged/judge"
$GAINROOT mount --bind -o ro "$JUDGE_UTILS" "$RUNDIR/merged/judge_utils"
$GAINROOT mount --bind -o ro "$COMPARE_SCRIPT" "$RUNDIR/merged/compare"
$GAINROOT mount --bind -o ro "$RUN_SCRIPT" "$RUNDIR/merged/run"

chroot_start "$CHROOTDIR" "$RUNDIR/merged"

# 我们不检查选手程序的返回值，比如 C 程序的 main 函数没有写 return 会导致返回值非零，这种不是崩溃导致的
runcheck $GAINROOT "$RUNGUARD" ${DEBUG:+-v} $CPUSET_OPT $MEMLIMIT_OPT $FILELIMIT_OPT $PROCLIMIT_OPT \
    --root "$RUNDIR/merged" \
    --work /judge \
    --no-core-dumps \
    --user "$RUNUSER" \
    --group "$RUNGROUP" \
    --wall-time "$TIMELIMIT" \
    --standard-error-file program.err \
    --out-meta program.meta -- \
    /run/run testdata.in program.out /judge/run 2>runguard.err

# 比较选手程序输出
logmsg $LOG_INFO "Comparing output"
force_umount "$RUNDIR/merged/judge"
$GAINROOT mount --bind "$RUNDIR/feedback" "$RUNDIR/merged/feedback"
$GAINROOT mount -t aufs none -odirs="$RUNDIR/run"=rw:"$WORKDIR/compile"=ro:"$TESTIN"=ro:"$TESTOUT"=ro "$RUNDIR/merged/judge"

exitcode=0
runcheck $GAINROOT "$RUNGUARD" ${DEBUG:+-v} $CPUSET_OPT \
    --root "$RUNDIR/merged" \
    --work /judge \
    --no-core-dumps \
    --user "$RUNUSER" \
    --group "$RUNGROUP" \
    --memory-limit $SCRIPTMEMLIMIT \
    --wall-time $SCRIPTTIMELIMIT \
    --file-limit $SCRIPTFILELIMIT \
    --out-meta compare.meta \
    -VJUDGE_UTILS=/judge_utils -- \
    "/compare/run" testdata.in program.out testdata.out /feedback > compare.tmp 2>&1

chroot_stop "$CHROOTDIR" "$RUNDIR/merged"

# 删除挂载点，因为我们已经确保有用的数据在 $WORKDIR/run-$uuid 中，因此删除挂载点即可。
force_umount "$RUNDIR/merged/judge"
force_umount "$RUNDIR/merged/judge_utils"
force_umount "$RUNDIR/merged/compare"
force_umount "$RUNDIR/merged/run"
force_umount "$RUNDIR/merged/feedback"
force_umount "$RUNDIR/merged"
rm -rf "$RUNDIR/merged"
rm -rf "$RUNDIR/work"
# RUNDIR 还剩下 compare.meta, compare.out, program.meta, program.err, system.out, runguard.err 供评测客户端检查
# RUNDIR 由评测客户端删除

# Append output validator error messages
# TODO: display extra
if [ -s feedback/judgeerror.txt ]; then
	printf "\\n---------- output validator (error) messages ----------\\n" >> feedback/judgemessage.txt
	cat feedback/judgeerror.txt >> feedback/judgemessage.txt
fi

# Append output validator stdin/stderr - display extra?
if [ -s compare.tmp ]; then
	printf "\\n---------- output validator stdout/stderr messages ----------\\n" >> feedback/judgemessage.txt
	cat compare.tmp >> feedback/judgemessage.txt
fi

logmsg $LOG_DEBUG "checking compare script exit-status: $exitcode"
if grep '^time-result: .*timelimit' compare.meta >/dev/null 2>&1; then
    logmsg $LOG_ERR "Comparing aborted after $SCRIPTTIMELIMIT seconds, compare script output: \\n$(cat compare.tmp)"
    cleanexit ${E_COMPARE_ERROR:-1}
fi

if [ ! -r program.meta ]; then
    error "'program.meta' is not readable"
fi

logmsg $LOG_DEBUG "Checking program run status"

timeused=$(grep '^time-used: '    program.meta | sed 's/time-used: //'   )
cputime=$( grep '^cpu-time: '     program.meta | sed 's/cpu-time: //'    )
walltime=$(grep '^wall-time: '    program.meta | sed 's/wall-time: //'   )
progexit=$(grep '^exitcode: '     program.meta | sed 's/exitcode: //'    )
stdout=$(  grep '^stdout-bytes: ' program.meta | sed 's/stdout-bytes: //')
stderr=$(  grep '^stderr-bytes: ' program.meta | sed 's/stderr-bytes: //')
memused=$( grep '^memory-bytes: ' program.meta | sed 's/memory-bytes: //')
signal=$(  grep '^signal: '       program.meta | sed 's/signal: //'      )
resource_usage="\
runtime: ${cputime}s cpu, ${walltime}s wall
memory used: ${memused} bytes"

if grep '^time-result: .*timelimit' program.meta >/dev/null 2>&1; then
    echo "Time Limit Exceeded" >> system.out
    echo "$resource_usage" >> system.out
    cleanexit ${E_TIME_LIMIT:-1}
fi

if grep -E '^output-truncated: ([a-z]+,)*stdout(,[a-z]+)*' program.meta >/dev/null 2>&1; then
    echo "Output Limit Exceeded" >> system.out
    echo "$resource_usage" >> system.out
    cleanexit ${E_OUTPUT_LIMIT:-1}
fi

if [ ! -z $signal ]; then
    case $signal in
        11) # SIGSEGV
            echo "Segmentation Fault" >> system.out
            echo "$resource_usage" >> system.out
            cleanexit ${E_SEG_FAULT:-1}
            ;;
        8) # SIGFPE
            echo "Floating Point Exception" >> system.out
            echo "$resource_usage" >> system.out
            cleanexit ${E_FLOATING_POINT:-1}
            ;;
        *)
            echo "Runtime Error" >> system.out
            echo "$resource_usage" >> system.out
            cleanexit ${E_RUNTIME_ERROR:-1}
            ;;
    esac
fi

# FIXME: C 语言程序可能会因为没有写 return 0; 导致非零
# 返回值而误判为 Runtime Error
# 经过测试，现在 gcc/g++ 会自动解决 main 函数没有 return 0 的问题，暂时不需要解决
if [ "$progexit" -ne 0 ]; then
    echo "Non-zero exitcode $progexit" >> system.out
    echo "$resource_usage" >> system.out
    cleanexit ${E_RUNTIME_ERROR:-1}
fi

if [ $exitcode -eq $RESULT_PC ] && [ ! -f "$RUNDIR/feedback/score.txt" ]; then
    logmsg $LOG_ERR "Compare script reports partial correct without score record."
    cleanexit ${E_COMPARE_ERROR:-1}
fi

case $exitcode in
    $RESULT_AC)
        echo "Accepted" >> system.out
        echo "$resource_usage" >> system.out
        cleanexit ${E_ACCEPTED:-1}
        ;;
    $RESULT_WA)
        echo "Wrong Answer" >> system.out
        echo "$resource_usage" >> system.out
        cleanexit ${E_WRONG_ANSWER:-1}
        ;;
    $RESULT_PE)
        echo "Presentation Error" >> system.out
        echo "$resource_usage" >> system.out
        cleanexit ${E_PRESENTATION_ERROR:-1}
        ;;
    $RESULT_PC)
        echo "Partial Correct" >> system.out
        echo "$resouce_usage" >> system.out
        cleanexit ${E_PARTIAL_CORRECT:-1}
        ;;
    *)
        logmsg $LOG_ERR "Comparing failed with exitcode $exitcode, compare script output:\\n$(cat feedback/judgemessage.txt)"
        cleanexit ${E_COMPARE_ERROR:-1}
        ;;
esac
